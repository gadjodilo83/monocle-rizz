import Head from "next/head";
import { Inter } from "next/font/google";
import styles from "@/styles/Home.module.css";
import { useState, useEffect } from "react";
import { ensureConnected } from "@/utils/bluetooth/js/main";
import { replRawMode, replSend } from "@/utils/bluetooth/js/repl";
import { Button } from "antd";
import { useWhisper } from "@chengsokdara/use-whisper";
import { app } from "@/utils/app";
import { execMonocle } from "@/utils/comms";

const inter = Inter({ subsets: ["latin"] });

const Home = () => {
  const [connected, setConnected] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [apiKey, setApiKey] = useState(process.env.NEXT_PUBLIC_OPENAI_API_TOKEN);
  const [chatGptResponse, setChatGptResponse] = useState("");
  const [typingIndex, setTypingIndex] = useState(0);
  const [translationDirection, setTranslationDirection] = useState("de-it");

  const { startRecording, stopRecording, transcript } = useWhisper({
    apiKey: apiKey,
    streaming: true,
    timeSlice: 500,
    whisperConfig: {
      language: translationDirection === "de-it" ? "de" : "it",
    },
  });

  const fetchGpt = async () => {
    const userPrompt = window.transcript;
    const systemPrompt = translationDirection === "de-it"
      ? `
          Du bist ein Sprachübersetzer und übersetzte jeden Input direkt in Deutsch und auf Italienisch. 
          Du machst auch Vorschläge, 
          um auf eine Frage eine Antwort zu geben oder wie man das Gespräch weiterführen könnte und dies jeweils immer auf deutsch und italienisch.
        `
      : `
          Sei un traduttore vocale che traduce ogni input direttamente da italiano a tedesco e viceversa.
          Fai anche suggerimenti per rispondere a una domanda o come continuare la conversazione, sia in tedesco che in italiano.
        `;

    const response = await fetch(`https://api.openai.com/v1/completions`, {
      body: JSON.stringify({
        model: "text-davinci-003",
        prompt:
          systemPrompt +
          "\ntranscript: " +
          userPrompt +
          "\nÜbersetzung auf deutsch und italienisch: ",
        temperature: 0.7,
        max_tokens: 512,
        frequency_penalty: 0,
        presence_penalty: 0,
      }),
      headers: {
        Authorization: `Bearer ${process.env.NEXT_PUBLIC_OPENAI_API_TOKEN}`,
        "Content-Type": "application/json",
      },
      method: "POST",
    });

    const resJson = await response.json();
    const res = resJson?.choices?.[0]?.text;
    if (!res) return;

    const splitRes = res.split("\n");
    const deutschUebersetzung = splitRes[0];
    const italienischUebersetzung = splitRes[1];
    const deutschVorschlag = splitRes[2];
    const italienischVorschlag = splitRes[3];
    const deutschGespraechsvorschlag = splitRes[4];
    const italienischGespraechsvorschlag = splitRes[5];

    console.log("Deutsche Übersetzung:", deutschUebersetzung);
    console.log("Italienische Übersetzung:", italienischUebersetzung);
    console.log("Antwortvorschlag auf Deutsch:", deutschVorschlag);
    console.log("Antwortvorschlag auf Italienisch:", italienischVorschlag);
    console.log("Vorschlag für Gesprächsweiterführung auf Deutsch:", deutschGespraechsvorschlag);
    console.log("Vorschlag für Gesprächsweiterführung auf Italienisch:", italienischGespraechsvorschlag);

    await displayRawRizz(
      `Deutsche Übersetzung: ${deutschUebersetzung}\n` +
      `Italienische Übersetzung: ${italienischUebersetzung}\n` +
      `Antwortvorschlag auf Deutsch: ${deutschVorschlag}\n` +
      `Antwortvorschlag auf Italienisch: ${italienischVorschlag}\n` +
      `Vorschlag für Gesprächsweiterführung auf Deutsch: ${deutschGespraechsvorschlag}\n` +
      `Vorschlag für Gesprächsweiterführung auf Italienisch: ${italienischGespraechsvorschlag}`
    );
  };

  useEffect(() => {
    const typingTimer = setInterval(() => {
      if (typingIndex < chatGptResponse.length) {
        setTypingIndex(typingIndex + 1);
      }
    }, 50);

    return () => clearInterval(typingTimer);
  }, [chatGptResponse, typingIndex]);

  return (
    <>
      <Head>
        <title>Monocle-Translator</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={`${inter.className} ${styles.main}`}>
        <div className="flex w-screen h-screen flex-col items-center justify-center">
          <p className="text-3xl">{connected ? "Connected" : "Disconnected"}</p>
          {transcript.text}
          <input
            type="text"
            value={apiKey}
            onChange={(e) => setApiKey(e.target.value)}
            placeholder="Enter API Key"
            style={{ marginBottom: "10px" }}
          />
          <Button
            type="primary"
            onClick={async () => {
              await ensureConnected(logger, relayCallback);
              app.run(execMonocle);
              await displayRawRizz();
            }}
            style={{ marginTop: "10px" }}
          >
            Connect
          </Button>
          <div className="flex items-center mt-5 gap-2">
            <Button onClick={onRecord}>
              {isRecording ? "Stop recording" : "Start recording"}
            </Button>
            <Button onClick={toggleTranslationDirection}>
              {translationDirection === "de-it" ? "DE > IT" : "IT > DE"}
            </Button>
            <Button onClick={fetchGpt}>Get response</Button>
          </div>
        </div>
      </main>
    </>
  );

  function relayCallback(msg) {
    if (!msg) {
      return;
    }
    if (msg.trim() === "trigger b") {
      // Left btn
      // fetchGpt();
    }

    if (msg.trim() === "trigger a") {
      // Right btn
      // onRecord();
    }
  }

  function onRecord() {
    isRecording ? stopRecording() : startRecording();
    setIsRecording(!isRecording);
  }

  function wrapText(inputText) {
    const block = 30;
    let text = [];
    for (let i = 0; i < 6; i++) {
      text.push(
        inputText.substring(block * i, block * (i + 1)).replace("\n", "")
      );
    }

    return text;
  }

  async function displayRizz(rizz) {
    if (!rizz) return;
    const splitText = wrapText(rizz);
    let replCmd = "import display;";

    for (let i = 0; i < splitText.length; i++) {
      replCmd += `display.text("${splitText[i]}", 0, ${i * 50}, 0xffffff);`;
    }

    replCmd += "display.show();";

    console.log("**** replCmd ****", replCmd);

    await replSend(replCmd);
  }

  async function displayRawRizz(rizz) {
    await replRawMode(true);
    await displayRizz(rizz);
  }

  async function logger(msg) {
    if (msg === "Connected") {
      setConnected(true);
    }
  }

  function toggleTranslationDirection() {
    setTranslationDirection(
      translationDirection === "de-it" ? "it-de" : "de-it"
    );
  }
};

export default Home;
